package euler.problem012

import scala.collection.mutable.ListBuffer

/**
 * <p>The sequence of triangle numbers is generated by adding the natural numbers.<br/> 
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. </p>
 * 
 * <p>The first ten terms would be:<br/>
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...</p>
 * 
 * <p>Let us list the factors of the first seven triangle numbers:<br/><br/>
 * <pre>
 *    1: 1
 *    3: 1,3
 *    6: 1,2,3,6
 *   10: 1,2,5,10
 *   15: 1,3,5,15
 *   21: 1,3,7,21
 *   28: 1,2,4,7,14,28
 * </pre>
 * <p>We can see that 28 is the first triangle number to have over five divisors.</p>
 * <p>What is the value of the first triangle number to have over five hundred divisors?</p>
 */
object App {

  private val triangleNumbers = new ListBuffer[Long]
  
  
  def main(args: Array[String]) {
    
  }
  
  /**
   * <p>Computing triangle numbers is a perfect dynamic programming problem: computing the Nth triangle
   * number requires the computation of all the 0...(N-1)th numbers.  To do this in Scala without streams, I'm 
   * using a ListBuffer where the index of the ListBuffer contains the triangle number associated to that N.</p>
   * <p>This method seeds the 0th element with 0 and then for any other call to {@code triangle(n)} will search
   * backwards until it finds a defined element at some index I.  Once a defined number is found at index I, the
   * algorithm "walks forward" to the requested index N, accumulating and storing the answer in the backing 
   * ListBuffer[I], ListBuffer[I+1], etc. until ListBuffer[N] is computed and returned.</p>
   *  
   * @param n The nth triangle number you want. 
   * @return The nth triangle number.
   */
  def triangle(n: Int): Long = {
    require(n >= 0)
    
    if(n == 0) {
      triangleNumbers.insert(0, 0)
    } 
    else {
      while(! triangleNumbers.isDefinedAt(n - 1)) {
        triangle(n - 1)
      }
      triangleNumbers.insert(n, triangleNumbers(n - 1) + n)
    }
    
    triangleNumbers(n)
  }
}
